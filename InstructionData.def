// The variant layout is modeled into the bit pattern
// the lowest four bits are the instruction width [variant] (maximum of 16 different widths, not 1-16 but variable based off of need)
// the remaining layout is dependent on the variant id
// NoArguments [ variant:3 | op: 5 ]
FirstX(Nop, NoArguments)
X(LeaveExecutionLoop, NoArguments) // a hack to support returning to native code
// OneRegister [ op: 8 | dest: 4 | unused: 4 ]
// TaggedOneRegister [ op: 8 | dest: 4 | tag: 4 ]
// TwoRegister [ op: 8 | dest: 4 | src: 4 ] // not as many allowed here
X(Load, TwoRegister)
X(Store, TwoRegister)
X(Move, TwoRegister)
X(Swap, TwoRegister)
X(PopRegister, TwoRegister)
X(PushRegister, TwoRegister)
// ThreeRegister [ op: 8 | dest: 4 | src0: 4 | src1: 4 | unused: 4 ] 
// TaggedThreeRegister [ op: 8 | dest: 4 | src0: 4 | src1: 4 | tag: 4 ] 
// @todo reimplement three register operators with type data embedded into the unused bits
//       if it makes sense
X(Add, ThreeRegister)
X(AddUnsigned, ThreeRegister)
X(FloatingPointAdd, ThreeRegister)
X(Subtract, ThreeRegister)
X(SubtractUnsigned, ThreeRegister)
X(FloatingPointSubtract, ThreeRegister)
X(Multiply, ThreeRegister)
X(MultiplyUnsigned, ThreeRegister)
X(FloatingPointMultiply, ThreeRegister)
X(Divide, ThreeRegister)
X(DivideUnsigned, ThreeRegister)
X(FloatingPointDivide, ThreeRegister)
X(Modulo, ThreeRegister)
X(ModuloUnsigned, ThreeRegister)
X(And, ThreeRegister)
X(AndUnsigned, ThreeRegister)
X(AndBoolean, ThreeRegister)
X(Or, ThreeRegister)
X(OrUnsigned, ThreeRegister)
X(OrBoolean, ThreeRegister)
X(Xor, ThreeRegister)
X(XorUnsigned, ThreeRegister)
X(XorBoolean, ThreeRegister)
X(GreaterThan, ThreeRegister)
X(FloatingPointGreaterThan, ThreeRegister)
X(GreaterThanUnsigned, ThreeRegister)
X(LessThan, ThreeRegister)
X(LessThanUnsigned, ThreeRegister)
X(FloatingPointLessThan, ThreeRegister)
// SignedImm16          [ op: 8 | unused: 8 | imm16 ] 
// Address24            [ op: 8 | imm24 ]
// TwoRegisterWithImm16 [ op: 8 | dest:4 | src0:4 | imm16 ]
// OneRegisterWithImm16 [ op: 8 | dest: 4 | unused: 4 | imm16 ]
X(AddImmediate, TwoRegisterWithImm16)
X(SubtractImmediate, TwoRegisterWithImm16)
X(MultiplyImmediate, CustomTwoRegisterWithImm16)
X(DivideImmediate, TwoRegisterWithImm16)
X(ModuloImmediate, TwoRegisterWithImm16)
X(AndImmediate, TwoRegisterWithImm16)
X(OrImmediate, TwoRegisterWithImm16)
X(GreaterThanImmediate, TwoRegisterWithImm16)
X(LessThanImmediate, TwoRegisterWithImm16)
X(XorImmediate, TwoRegisterWithImm16)
X(ShiftRightImmediate, TwoRegisterWithImm16)
X(ShiftLeftImmediate, TwoRegisterWithImm16)
X(EqualsImmediate, TwoRegisterWithImm16)
X(UnsignedAddImmediate, TwoRegisterWithImm16)
X(UnsignedSubtractImmediate, TwoRegisterWithImm16)
X(UnsignedMultiplyImmediate, CustomTwoRegisterWithImm16)
X(UnsignedDivideImmediate, TwoRegisterWithImm16)
X(UnsignedModuloImmediate, TwoRegisterWithImm16)
X(UnsignedAndImmediate, TwoRegisterWithImm16)
X(UnsignedOrImmediate, TwoRegisterWithImm16)
X(UnsignedGreaterThanImmediate, TwoRegisterWithImm16)
X(UnsignedLessThanImmediate, TwoRegisterWithImm16)
X(UnsignedXorImmediate, TwoRegisterWithImm16)
X(UnsignedShiftRightImmediate, TwoRegisterWithImm16)
X(UnsignedShiftLeftImmediate, TwoRegisterWithImm16)
X(UnsignedEqualsImmediate, TwoRegisterWithImm16)
// TwoRegister          [ op: 8 | dest: 4 | src: 4 ]
// OneRegisterWithImm64 [ op: 8 | dest: 4 | unused: 4 | imm64 ]
// OneRegisterWithImm32 [ op: 8 | dest: 4 | unused: 4 | imm32 ]
// FourRegister         [ op: 8 | dest: 4 | src0: 4 | src1: 4 | src2: 4 | unused: 8 ] // compact version
// FiveRegister         [ op: 8 | dest: 4 | src0: 4 | src1: 4 | src2: 4 | src3: 4 | unused: 4 ]
// OneRegisterWithImm16 [ op: 8 | dest: 4 | unused: 4 | imm16 ]
X(PrintString, TwoRegister) // read two registers to get start and length in memory
X(Minus, TwoRegister) // minus unsigned makes no sense
X(MinusUnsigned, TwoRegister)
X(MinusFloatingPoint, TwoRegister)
X(Not, TwoRegister) // not is implicitly unsigned and works for boolean ops as well
X(NotBoolean, TwoRegister)
X(NotSigned, TwoRegister)
X(LoadImmediate32, OneRegisterWithImm32)
X(LoadImmediate64, OneRegisterWithImm64)
X(ShiftRight, ThreeRegister)
X(ShiftRightUnsigned, ThreeRegister)
X(ShiftLeft, ThreeRegister)
X(ShiftLeftUnsigned, ThreeRegister)
X(Equals, ThreeRegister)
X(EqualsUnsigned, ThreeRegister)
X(EqualsBoolean, ThreeRegister)
X(FloatingPointEquals, ThreeRegister)
X(Pow, ThreeRegister)
X(FloatingPointPow, ThreeRegister)
X(PowUnsigned, ThreeRegister)
X(GreaterThanOrEqualTo, ThreeRegister)
X(GreaterThanOrEqualToUnsigned, ThreeRegister)
X(FloatingPointGreaterThanOrEqualTo, ThreeRegister)
X(LessThanOrEqualTo, ThreeRegister)
X(LessThanOrEqualToUnsigned, ThreeRegister)
X(FloatingPointLessThanOrEqualTo, ThreeRegister)
X(NotEqual, ThreeRegister)
X(NotEqualBoolean, ThreeRegister)
X(NotEqualUnsigned, ThreeRegister)
X(FloatingPointNotEqual, ThreeRegister)
X(NotEqualImmediate, CustomTwoRegisterWithImm16)
X(UnsignedNotEqualImmediate, CustomTwoRegisterWithImm16)
X(GreaterThanOrEqualToImmediate, CustomTwoRegisterWithImm16)
X(UnsignedGreaterThanOrEqualToImmediate, CustomTwoRegisterWithImm16)
X(LessThanOrEqualToImmediate, CustomTwoRegisterWithImm16)
X(UnsignedLessThanOrEqualToImmediate, CustomTwoRegisterWithImm16)

X(Jump, SignedImm16)
X(CallSubroutine, SignedImm16)
X(ConditionalBranch, OneRegisterWithImm16)
X(ConditionalCallSubroutine, OneRegisterWithImm16)
X(CallSubroutineAbsolute, Immediate24)
X(JumpAbsolute, Immediate24)
X(ReturnSubroutine, NoArguments)
X(ConditionalReturnSubroutine, OneRegister)
X(CallSubroutineIndirect, OneRegister)
X(JumpIndirect, OneRegister)
X(ConditionalBranchIndirect, TwoRegister)
X(ConditionalCallSubroutineIndirect, TwoRegister)
X(IfStatement, ThreeRegister) // jump to one of two locations based off of the condition
X(CallIfStatement, ThreeRegister) // call one of the two locations based off of the condition

X(TypeValue, TaggedOneRegister)
