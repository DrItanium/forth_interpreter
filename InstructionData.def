// The variant layout is modeled into the bit pattern
// the lowest four bits are the instruction width [variant] (maximum of 16 different widths, not 1-16 but variable based off of need)
// the remaining layout is dependent on the variant id
// NoArguments [ variant:3 | op: 5 ]
FirstX(Nop, NoArguments)
X(ReturnSubroutine, NoArguments)
X(LeaveExecutionLoop, NoArguments) // a hack to support returning to native code
// OneRegister [ op: 8 | dest: 4 | unused: 4 ]
// TwoRegister [ op: 8 | dest: 4 | src: 4 ] // not as many allowed here
X(TypeValue, OneRegister)
X(TypeValueUnsigned, OneRegister)
X(TypeValueFloatingPoint, OneRegister)
X(TypeValueBoolean, OneRegister)
X(PrintChar, OneRegister)          // print a character stored in a register
X(TypeDatum, OneRegister)          // print the register with all of its contents
X(ConditionalReturnSubroutine, OneRegister)
X(CallSubroutineIndirect, OneRegister)
X(JumpIndirect, TwoRegister)
X(ConditionalBranchIndirect, TwoRegister)
X(ConditionalCallSubroutineIndirect, TwoRegister)
X(Load, TwoRegister)
X(Store, TwoRegister)
X(Move, TwoRegister)
X(Swap, TwoRegister)
X(PopRegister, TwoRegister)
X(PushRegister, TwoRegister)
//X(LoadHalfAddress, TwoRegister)
//X(LoadQuarterAddress, TwoRegister)
//X(LoadByte, TwoRegister)
//X(StoreByte, TwoRegister)
//X(StoreHalfAddress, TwoRegister)
//X(StoreQuarterAddress, TwoRegister)
// ThreeRegister [ op: 8 | dest: 4 | src0: 4 | src1: 4 | unused: 4 ] 
X(Add, ThreeRegister)
X(AddUnsigned, ThreeRegister)
X(FloatingPointAdd, ThreeRegister)
X(Subtract, ThreeRegister)
X(SubtractUnsigned, ThreeRegister)
X(FloatingPointSubtract, ThreeRegister)
X(Multiply, ThreeRegister)
X(MultiplyUnsigned, ThreeRegister)
X(FloatingPointMultiply, ThreeRegister)
X(Divide, ThreeRegister)
X(DivideUnsigned, ThreeRegister)
X(FloatingPointDivide, ThreeRegister)
X(Modulo, ThreeRegister)
X(ModuloUnsigned, ThreeRegister)
X(And, ThreeRegister)
X(AndUnsigned, ThreeRegister)
X(AndBoolean, ThreeRegister)
X(Or, ThreeRegister)
X(OrUnsigned, ThreeRegister)
X(OrBoolean, ThreeRegister)
X(Xor, ThreeRegister)
X(XorUnsigned, ThreeRegister)
X(XorBoolean, ThreeRegister)
X(GreaterThan, ThreeRegister)
X(FloatingPointGreaterThan, ThreeRegister)
X(GreaterThanUnsigned, ThreeRegister)
X(LessThan, ThreeRegister)
X(LessThanUnsigned, ThreeRegister)
X(FloatingPointLessThan, ThreeRegister)
// SignedImm16          [ op: 8 | unused: 8 | imm16 ] 
// Address24            [ op: 8 | imm24 ]
// TwoRegisterWithImm16 [ op: 8 | dest:4 | src0:4 | imm16 ]
// OneRegisterWithImm16 [ op: 8 | dest: 4 | unused: 4 | imm16 ]
X(Jump, SignedImm16)
X(CallSubroutine, SignedImm16)
X(CallSubroutineAbsolute, Immediate24)
X(JumpAbsolute, Immediate24)
X(ConditionalBranch, OneRegisterWithImm16)
X(ConditionalCallSubroutine, OneRegisterWithImm16)
X(AddImmediate, TwoRegisterWithImm16)
X(SubtractImmediate, TwoRegisterWithImm16)
X(MultiplyImmediate, TwoRegisterWithImm16)
X(DivideImmediate, TwoRegisterWithImm16)
X(ModuloImmediate, TwoRegisterWithImm16)
X(AndImmediate, TwoRegisterWithImm16)
X(OrImmediate, TwoRegisterWithImm16)
X(GreaterThanImmediate, TwoRegisterWithImm16)
X(LessThanImmediate, TwoRegisterWithImm16)
X(XorImmediate, TwoRegisterWithImm16)
X(ShiftRightImmediate, TwoRegisterWithImm16)
X(ShiftLeftImmediate, TwoRegisterWithImm16)
X(EqualsImmediate, TwoRegisterWithImm16)
X(UnsignedAddImmediate, TwoRegisterWithImm16)
X(UnsignedSubtractImmediate, TwoRegisterWithImm16)
X(UnsignedMultiplyImmediate, TwoRegisterWithImm16)
X(UnsignedDivideImmediate, TwoRegisterWithImm16)
X(UnsignedModuloImmediate, TwoRegisterWithImm16)
X(UnsignedAndImmediate, TwoRegisterWithImm16)
X(UnsignedOrImmediate, TwoRegisterWithImm16)
X(UnsignedGreaterThanImmediate, TwoRegisterWithImm16)
X(UnsignedLessThanImmediate, TwoRegisterWithImm16)
X(UnsignedXorImmediate, TwoRegisterWithImm16)
X(UnsignedShiftRightImmediate, TwoRegisterWithImm16)
X(UnsignedShiftLeftImmediate, TwoRegisterWithImm16)
X(UnsignedEqualsImmediate, TwoRegisterWithImm16)
// TwoRegister          [ op: 8 | dest: 4 | src: 4 ]
// OneRegisterWithImm64 [ op: 8 | dest: 4 | unused: 4 | imm64 ]
// OneRegisterWithImm32 [ op: 8 | dest: 4 | unused: 4 | imm32 ]
// FourRegister         [ op: 8 | dest: 4 | src0: 4 | src1: 4 | src2: 4 | unused: 8 ] // compact version
// FiveRegister         [ op: 8 | dest: 4 | src0: 4 | src1: 4 | src2: 4 | src3: 4 | unused: 4 ]
// OneRegisterWithImm16 [ op: 8 | dest: 4 | unused: 4 | imm16 ]
// OneRegisterWithImm48 [ op: 8 | dest: 4 | unused: 4 | imm48 ]
X(DecodeBits, FourRegister)
X(EncodeBits, FiveRegister)
X(PrintString, TwoRegister) // read two registers to get start and length in memory
X(Minus, TwoRegister) // minus unsigned makes no sense
X(MinusUnsigned, TwoRegister)
X(MinusFloatingPoint, TwoRegister)
X(Not, TwoRegister) // not is implicitly unsigned and works for boolean ops as well
X(NotBoolean, TwoRegister)
X(NotSigned, TwoRegister)
X(LoadImmediate32, OneRegisterWithImm32)
X(LoadImmediate64, OneRegisterWithImm64)
X(ShiftRight, ThreeRegister)
X(ShiftRightUnsigned, ThreeRegister)
X(ShiftLeft, ThreeRegister)
X(ShiftLeftUnsigned, ThreeRegister)
X(Equals, ThreeRegister)
X(EqualsUnsigned, ThreeRegister)
X(EqualsBoolean, ThreeRegister)
X(FloatingPointEquals, ThreeRegister)
X(Pow, ThreeRegister)
X(FloatingPointPow, ThreeRegister)
X(PowUnsigned, ThreeRegister)

