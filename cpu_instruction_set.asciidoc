Forth CPU
=========

The CPU powering this forth implementation is a fully working chip. 
It has been designed to act as the execution backend of this forth implementation.

It has the following features:

- Encoding space up to 16 registers (currently 10 registers are defined!)
- Dual stack pointers, one for parameters and another for subroutine
- 64-bit words
- Instructions are variable length and must fit within a single word
- 27-bit byte level program counter
- 24-bit word level program counter
- Has an extra 64 k of storage for cpu variables
- Support for floating point, unsigned, signed, and boolean values from the same registers.
- Compressed versions of standard instructions useful for implementing forth words in less space


Registers
=========

Currently, 10 of the 16 total possible registers are defined:

- A
- B
- C
- S
- X
- SP
- SP2
- DP
- Index
- Temporary

Registers A, B, and C are meant to be the general purpose registers used in carrying
out forth operations. Register S is meant to be used for selection purposes.
Register X is meant to be used for storing absolute addresses. Register SP is the
parameter stack pointer. Register SP2 is the subroutine stack pointer. DP is the
dictionary pointer, it is meant to be a pointer to the front of the dictionary.
The Index register is designed to be used when executing a forth word, it keeps
track of where the cpu currently is in the word. The Temporary register is meant
for macros and other purposes where the data can be safely volatile.


Instruction Set
===============

The instruction set of the core is very simple with instruction widths ranging from 1 byte to 8 bytes. 
Multiple instructions are encoded into a single 64-bit molecule. Instructions cannot span
multiple molecules. If the opcode zero is encountered then the processor will skip executing the
rest of the molecule.
The one byte instructions are compressed versions of standard operations where the 
registers used are fixed to a specific kind. The wider instructions allow one to
specify register combinations. The type of the operand is described in the instruction op code.
Thus a floating point add is a different opcode to an unsigned add, etc. 

The format of the instructions is as follows:

All instructions start with an 8-bit type code.

All eight bits are devoted to the type code, there is no way to determine the 
width from the bit pattern itself. fields that are marked as free are not part of the instruction and can hold 
another instruction.

.Instruction formats
|==========================
| Form                    | byte 0 | byte 1                                      | byte 2                               | byte 3   | byte 4   | byte 5   | byte 6   | byte 7
| Single Byte             | opcode | _free_                                      | _free_                               | _free_   | _free_   | _free_   | _free_   | _free_
| Two Operand             | opcode | _destination_ [0->3] , _source_ [4->7]      | _free_                               | _free_   | _free_   | _free_   | _free_   | _free_
| Three Operand           | opcode | _destination_ [0->3] , _source_ [4->7]      | _source1_ [0->3] , _always_ 0 [4->7] | _free_   | _free_   | _free_   | _free_   | _free_
| Three Operand Immediate | opcode | _destination_ [0->3] , _source_ [4->7]    2+| _imm16_ [0->15] | _free_   | _free_   | _free_   | _free_
| Increment / Decrement   | opcode | _destination_ [0->3] , _imm4_ (one added to this immediate by cpu) [4->7] | _free_   | _free_   | _free_   | _free_   | _free_ | _free_
| Jump                    | opcode 2+| _imm16_ [0->15] | _free_   | _free_    | _free_   | _free_ | _free_
| Conditional Jump        | opcode | _destination_ [0->3] , _always_ 0 [4->7] 2+| _imm16_ [0->15] | _free_    | _free_   | _free_ | _free_
| Load Immediate 48       | opcode | _destination_ [0->3] , _always_ 0 [4->7]  6+| _imm48_ [0->47]
|==========================
