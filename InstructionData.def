// The variant layout is modeled into the bit pattern
// the lowest four bits are the instruction width [variant] (maximum of 16 different widths, not 1-16 but variable based off of need)
// the remaining layout is dependent on the variant id
// code 0: OneByte [ variant:3 | op: 5 ] // maximum of 32 ops in this class
//      Opcodes (in numerical order)
OneByte(Nop)
OneByte(ReturnSubroutine)
OneByte(LeaveExecutionLoop) // a hack to support returning to native code
// code 1: TwoByte [ variant:3 | control: 13 ] // multiple layouts
//          OneRegister [ variant:3 | op: 5 | dest: 4 | unused: 4 ]
TwoByte(TypeValue, OneRegister)
TwoByte(TypeValueUnsigned, OneRegister)
TwoByte(TypeValueFloatingPoint, OneRegister)
TwoByte(TypeValueBoolean, OneRegister)
TwoByte(ConditionalReturnSubroutine, OneRegister)
TwoByte(CallSubroutineIndirect, OneRegister)
TwoByte(PrintChar, OneRegister)          // print a character stored in a register
TwoByte(TypeDatum, OneRegister)          // print the register with all of its contents
//          TwoRegister [ variant:3 | op: 5 | dest: 4 | src: 4 ] // not as many allowed here
TwoByte(JumpIndirect, TwoRegister)
TwoByte(ConditionalBranchIndirect, TwoRegister)
TwoByte(ConditionalCallSubroutineIndirect, TwoRegister)
TwoByte(Load, TwoRegister)
TwoByte(Store, TwoRegister)
TwoByte(Move, TwoRegister)
TwoByte(Swap, TwoRegister)
TwoByte(PopRegister, TwoRegister)
TwoByte(PushRegister, TwoRegister)
TwoByte(LoadHalfAddress, TwoRegister)
TwoByte(LoadQuarterAddress, TwoRegister)
TwoByte(LoadByte, TwoRegister)
TwoByte(StoreByte, TwoRegister)
TwoByte(StoreHalfAddress, TwoRegister)
TwoByte(StoreQuarterAddress, TwoRegister)
// code 2: ThreeByte [ variant:3 | kind: 2 | control:18 ]
//          ThreeRegister [ variant:3 [2] | kind: 2 [0] | op: 6 | dest: 4 | src0: 4 | src1: 4] 
ThreeByte(Add, ThreeRegister)
ThreeByte(Subtract, ThreeRegister)
ThreeByte(Multiply, ThreeRegister)
ThreeByte(Divide, ThreeRegister)
ThreeByte(Modulo, ThreeRegister)
ThreeByte(And, ThreeRegister)
ThreeByte(Or, ThreeRegister)
ThreeByte(GreaterThan, ThreeRegister)
ThreeByte(LessThan, ThreeRegister)
ThreeByte(Xor, ThreeRegister)
ThreeByte(ShiftRight, ThreeRegister)
ThreeByte(ShiftLeft, ThreeRegister)
ThreeByte(Equals, ThreeRegister)
ThreeByte(Pow, ThreeRegister)
ThreeByte(AddUnsigned, ThreeRegister)
ThreeByte(SubtractUnsigned, ThreeRegister)
ThreeByte(MultiplyUnsigned, ThreeRegister)
ThreeByte(DivideUnsigned, ThreeRegister)
ThreeByte(ModuloUnsigned, ThreeRegister)
ThreeByte(AndUnsigned, ThreeRegister)
ThreeByte(OrUnsigned, ThreeRegister)
ThreeByte(GreaterThanUnsigned, ThreeRegister)
ThreeByte(LessThanUnsigned, ThreeRegister)
ThreeByte(XorUnsigned, ThreeRegister)
ThreeByte(ShiftRightUnsigned, ThreeRegister)
ThreeByte(ShiftLeftUnsigned, ThreeRegister)
ThreeByte(EqualsUnsigned, ThreeRegister)
ThreeByte(PowUnsigned, ThreeRegister)
ThreeByte(FloatingPointAdd, ThreeRegister)
ThreeByte(FloatingPointSubtract, ThreeRegister)
ThreeByte(FloatingPointMultiply, ThreeRegister)
ThreeByte(FloatingPointDivide, ThreeRegister)
ThreeByte(FloatingPointGreaterThan, ThreeRegister)
ThreeByte(FloatingPointLessThan, ThreeRegister)
ThreeByte(FloatingPointEquals, ThreeRegister)
ThreeByte(FloatingPointPow, ThreeRegister)
ThreeByte(AndBoolean, ThreeRegister)
ThreeByte(OrBoolean, ThreeRegister)
ThreeByte(XorBoolean, ThreeRegister)
ThreeByte(EqualsBoolean, ThreeRegister)
//          FourRegister  [ variant:3 [2] | kind: 2 [1] | op: 3 | dest: 4 | src0: 4 | src1: 4 | src2: 4] // compact version
ThreeByte(DecodeBits, FourRegister)
//          SignedImm16   [ variant:3 [2] | kind: 2 [2] | op: 3 | imm16 ] 
ThreeByte(Jump, SignedImm16)
ThreeByte(CallSubroutine, SignedImm16)
// code 3: FourByte [ variant:3 | kind:2 | control: 27 ]
//          FiveRegister         [ variant:3 [3] | kind: 2 [0] | op: 7 | dest: 4 | src0: 4 | src1: 4 | src2: 4 | src3: 4 ]
FourByte(EncodeBits, FiveRegister)
//          Immediate24          [ variant:3 [3] | kind: 2 [1] | op: 3 | imm24] 
FourByte(JumpAbsolute, Immediate24)
//          OneRegisterWithImm16 [ variant:3 [3] | kind: 2 [2] | op: 7  | dest: 4 | imm16 ]
FourByte(ConditionalBranch, OneRegisterWithImm16)
FourByte(ConditionalCallSubroutine, OneRegisterWithImm16)
FourByte(LoadImmediate16, OneRegisterWithImm16)
// code 4: EightByte [ variant:3 | kind:2 | control: 59 ]
//         OneRegisterWithImm48  [ variant: 3 [4] | kind: 2 [0] | op: 7 | dest: 4 | imm48 ]
EightByte(LoadImmediate48, OneRegisterWithImm48)
// code 5: FiveByte [ variant:3 | kind:2 | control: 35 ]
//         TwoRegisterWithImm16 [ variant: 3 [5] | kind:2 [0] | op: 6 | unused: 5 | dest:4 | src0:4 | imm16 ]
FiveByte(AddImmediate, TwoRegisterWithImm16)
FiveByte(SubtractImmediate, TwoRegisterWithImm16)
FiveByte(MultiplyImmediate, TwoRegisterWithImm16)
FiveByte(DivideImmediate, TwoRegisterWithImm16)
FiveByte(ModuloImmediate, TwoRegisterWithImm16)
FiveByte(AndImmediate, TwoRegisterWithImm16)
FiveByte(OrImmediate, TwoRegisterWithImm16)
FiveByte(GreaterThanImmediate, TwoRegisterWithImm16)
FiveByte(LessThanImmediate, TwoRegisterWithImm16)
FiveByte(XorImmediate, TwoRegisterWithImm16)
FiveByte(ShiftRightImmediate, TwoRegisterWithImm16)
FiveByte(ShiftLeftImmediate, TwoRegisterWithImm16)
FiveByte(EqualsImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedAddImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedSubtractImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedMultiplyImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedDivideImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedModuloImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedAndImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedOrImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedGreaterThanImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedLessThanImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedXorImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedShiftRightImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedShiftLeftImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedEqualsImmediate, TwoRegisterWithImm16)
// code 6: GrabBag [ variant:3 | kind: 3 | ... ] 
//         ExtendedTwoRegister0 [ variant: 3 [6] | kind:3 [0] | op: 2 | dest: 4 | src: 4 
GrabBag(PrintString, ExtendedTwoRegister0) // read two registers to get start and length in memory
GrabBag(Minus, ExtendedTwoRegister0) // minus unsigned makes no sense
GrabBag(MinusUnsigned, ExtendedTwoRegister0)
GrabBag(MinusFloatingPoint, ExtendedTwoRegister0)
//         ExtendedTwoRegister0 [ variant: 3 [6] | kind:3 [1] | op: 2 | dest: 4 | src: 4 
GrabBag(Not, ExtendedTwoRegister1) // not is implicitly unsigned and works for boolean ops as well
GrabBag(NotBoolean, ExtendedTwoRegister1)
GrabBag(NotSigned, ExtendedTwoRegister1)
// code 7: ExtendedVariant [ variant: 3 [8] | subvariant: 3 | ... ]
// code 7, subvariant 0 TenByte : [ variant: 3 [8] | subvariant: 3 [0] | kind: 2 | control: 72 ]
//          OneRegisterWithImm64 [ variant: 3 [8] | subvariant: 3 [0] | kind: 2 [0] | op: 4 | dest: 4 | imm64 ]
ExtendedVariant(TenByte, LoadImmediate64, OneRegisterWithImm64)
// code 7, subvariant 1 SixByte : [ variant: 3 [8] | subvariant: 3 [1] | kind: 2 | control: 40 ]
//          OneRegisterWithImm32 [ variant: 3 [8] | subvariant: 3 [1] | kind: 2 [0] | op: 4 | dest: 4 | imm32 ]
ExtendedVariant(SixByte, LoadImmediate32, OneRegisterWithImm32)

