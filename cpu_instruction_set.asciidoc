Forth CPU
=========

The CPU powering this forth implementation is a fully working chip. 
It has been designed to act as the execution backend of this forth implementation.

It has the following features:

- Encoding space up to 16 registers (currently 10 registers are defined!)
- Dual stack pointers, one for parameters and another for subroutine
- 64-bit words
- Instructions are variable length and must fit within a single word
- 27-bit byte level program counter
- 24-bit word level program counter
- Has an extra 64 k of storage for cpu variables
- Support for floating point, unsigned, signed, and boolean values from the same registers.
- Compressed versions of standard instructions useful for implementing forth words in less space


Registers
=========

Currently, 10 of the 16 total possible registers are defined:

- A
- B
- C
- S
- X
- SP
- SP2
- DP
- Index
- Temporary

Registers A, B, and C are meant to be the general purpose registers used in carrying
out forth operations. Register S is meant to be used for selection purposes.
Register X is meant to be used for storing absolute addresses. Register SP is the
parameter stack pointer. Register SP2 is the subroutine stack pointer. DP is the
dictionary pointer, it is meant to be a pointer to the front of the dictionary.
The Index register is designed to be used when executing a forth word, it keeps
track of where the cpu currently is in the word. The Temporary register is meant
for macros and other purposes where the data can be safely volatile.


Instruction Set
===============

The instruction set of the core is very simple with instruction widths ranging from 1 byte to 8 bytes. 
Multiple instructions are encoded into a single 64-bit molecule. Instructions cannot span
multiple molecules. If the opcode zero is encountered then the processor will skip executing the
rest of the molecule.
The one byte instructions are compressed versions of standard operations where the 
registers used are fixed to a specific kind. The wider instructions allow one to
specify register combinations. The type of the operand is described in the instruction op code.
Thus a floating point add is a different opcode to an unsigned add, etc. 

The format of the instructions is as follows:

All instructions start with an 8-bit type code.

All eight bits are devoted to the type code, there is no way to determine the 
width from the bit pattern itself. fields that are marked as free are not part of the instruction and can hold 
another instruction.

.Instruction formats
|==========================
| Form                      | width  | byte 0 | byte 1                                      | byte 2                               | byte 3   | byte 4   | byte 5   | byte 6   | byte 7
| Single Byte               | 1      | opcode | _free_                                      | _free_                               | _free_   | _free_   | _free_   | _free_   | _free_
| Two Operand               | 2      | opcode | _destination_ [0->3] , _source_ [4->7]      | _free_                               | _free_   | _free_   | _free_   | _free_   | _free_
| Three Operand             | 3      | opcode | _destination_ [0->3] , _source_ [4->7]      | _source1_ [0->3] , _always_ 0 [4->7] | _free_   | _free_   | _free_   | _free_   | _free_
| Three Operand Immediate   | 4      | opcode | _destination_ [0->3] , _source_ [4->7]    2+| _imm16_ [0->15] | _free_   | _free_   | _free_   | _free_
| Increment / Decrement     | 2      | opcode | _destination_ [0->3] , _imm4_ (one added to this immediate by cpu) [4->7] | _free_   | _free_   | _free_   | _free_   | _free_ | _free_
| Jump                      | 3      | opcode 2+| _imm16_ [0->15] | _free_   | _free_    | _free_   | _free_ | _free_
| Jump Indirect             | 2      | opcode | _destination_ [0->3] , _always_ 0 | _free_ | _free_   | _free_    | _free_   | _free_ | _free_
| Conditional Jump          | 4      | opcode | _destination_ [0->3] , _always_ 0 [4->7] 2+| _imm16_ [0->15] | _free_    | _free_   | _free_ | _free_
| Conditional Jump Indirect | 2      | opcode | _destination_ [0->3] , _source_ [4->7] | _free_ | _free_ | _free_    | _free_   | _free_ | _free_
| Set Immediate 16          | 4      | opcode | _destination_ [0->3] , _always_ 0 [4->7]    2+| _imm16_ [0->15] | _free_   | _free_   | _free_   | _free_
| Load Immediate 48         | 8      | opcode | _destination_ [0->3] , _always_ 0 [4->7]  6+| _imm48_ [0->47]
|==========================

The single byte versions of the three operand and two operand instructions implicitly use
registers A and B as the source registers (A is source0 and B is source1 (if used)) with register
C being the destination. The push and pop specific registers implicitly use register SP.

The one byte version of multiply (regardless of variant) would be used if the instruction looks like this:

```
multiplyf C = A, B (floating-point)
multiply  C = A, B (signed)
multiplyu C = A, B (unsigned)
```

The jump and conditional jump forms which are the call variety, use register SP2 implicitly.

loading a full 64-bit immediate is a combination of:

```
loadimm48 ?dest = ?imm48
setimm16_highest ?dest = ?imm16
```

This requires two molecules to complete with 4 bytes left over in the second molecule.

Throughout the rest of this document, the double semi-colon will imply a stop.
Unfillable bytes in an instructions must be set to zero

IMPORTANT: The typed operations assume that the programmer has put the right data into the registers.
If doing a floating point add on two integers then the integers are interpreted as floating point numbers
using the defined bit pattern.

Because the number of different operations is vast with this chip, the following table will layout the 
opcodes by kind. The table will show what kind of operands are supported (thus implying a different 
opcode):

.Instruction concepts and opcode mnemonics for supported data types
|====================================
| Concept     | Signed | Unsigned | Floating Point | Boolean | Untyped | Implied One Byte Arguments
| stop        |    |      |            |     | stop    | 
| add         | add    | addu     | addf           |     |     | C = A, B
| subtract    | sub    | subu     | subf           |     |     | C = A, B
| multiply    | mul    | mulu     | mulf           |     |     | C = A, B
| divide      | div    | divu     | divf           |     |     | C = A, B
| modulo      | mod    | modu     |            |     |     | C = A, B
| shift left  | shl    | shlu     |            |     |     | C = A, B
| shift right | shr    | shru     |            |     |     | C = A, B
| and | and | andu |  | andb |  | C = A, B
| or | or | oru |  | orb |  | C = A, B
| xor | xor | xoru |  | xorb |  | C = A, B
| not | not | notu |  | notb |  | C = A
| minus | minus | minusu | minusf |  |  | C = A
| greater than | cmpgt | cmpgtu | cmpgtf |  |  | C = A, B
| less than | cmplt | cmpltu | cmpltf |  |  | C = A, B
| equals | cmpeq | cmpequ | cmpeqf | cmpeqb |  | C = A, B
| pow    | pow | powu | powf |  |  | C = A, B
| increment | incr | incru | incrf |  |  | 
| decrement | decr | decru | decrf |  |  | 
| type value | type | typeu | typef | typeb |  | A
| load |  |  |  |  | load |  
| store |  |  |  |  | store |  
| Set bits [0:15]  |  |  |  |  | setimm16.lowest | 
| Set bits [16:31] |  |  |  |  | setimm16.lower | 
| Set bits [32:47] |  |  |  |  | setimm16.higher | 
| Set bits [48:63] |  |  |  |  | setimm16.highest | 
| move register to register |  |  |  |  | move | 
| swap register contents |  |  |  |  | swap | 
| Pop Top of Stack into Designated Register | | | | | pop | (A, SP) , (B, SP), (C, SP)
| Push Designated Register onto Stack | | | | | push | (SP, A), (B, SP), (C, SP)
| Jump | | | | | jump | 
| Jump Indirect | | | | | jumpi | 
| Jump Absolute | | | | | jumpa | 
| Call Subroutine | | | | | call | 
| Call Subroutine Indirect | | | | | calli | 
| Return From Subroutine | | | | | ret | 
| load immediate bits [48:63] |  |  |  |  | loadimm48 | 
|====================================



