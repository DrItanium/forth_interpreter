// The variant layout is modeled into the bit pattern
// the lowest four bits are the instruction width [variant] (maximum of 16 different widths, not 1-16 but variable based off of need)
// the remaining layout is dependent on the variant id
// code 0: OneByte [ variant:3 | op: 5 ] // maximum of 32 ops in this class
//      Opcodes (in numerical order)
OneByte(Nop)
OneByte(ReturnSubroutine)
OneByte(LeaveExecutionLoop) // a hack to support returning to native code
// code 1: TwoByte [ variant:3 | control: 13 ] // multiple layouts
//          OneRegister [ variant:3 | op: 5 | dest: 4 | unused: 4 ]
//          TwoRegister [ variant:3 | op: 5 | dest: 4 | src: 4 ] // not as many allowed here
TwoByte(TypeValue, OneRegister)
TwoByte(TypeValueUnsigned, OneRegister)
TwoByte(TypeValueFloatingPoint, OneRegister)
TwoByte(TypeValueBoolean, OneRegister)
TwoByte(ConditionalReturnSubroutine, OneRegister)
TwoByte(CallSubroutineIndirect, OneRegister)
TwoByte(PrintChar, OneRegister)          // print a character stored in a register
TwoByte(TypeDatum, OneRegister)          // print the register with all of its contents
TwoByte(JumpIndirect, TwoRegister)
TwoByte(ConditionalBranchIndirect, TwoRegister)
TwoByte(ConditionalCallSubroutineIndirect, TwoRegister)
TwoByte(Load, TwoRegister)
TwoByte(Store, TwoRegister)
TwoByte(Move, TwoRegister)
TwoByte(Swap, TwoRegister)
TwoByte(PopRegister, TwoRegister)
TwoByte(PushRegister, TwoRegister)
TwoByte(LoadHalfAddress, TwoRegister)
TwoByte(LoadQuarterAddress, TwoRegister)
TwoByte(LoadByte, TwoRegister)
TwoByte(StoreByte, TwoRegister)
TwoByte(StoreHalfAddress, TwoRegister)
TwoByte(StoreQuarterAddress, TwoRegister)
// code 2: ThreeByte [ variant:3 | opcontrol:21 ]
//          ThreeRegister [ variant:3 [2] | op: 6 | unused: 3 | dest: 4 | src0: 4 | src1: 4] 
ThreeByte(Add, ThreeRegister)
ThreeByte(Subtract, ThreeRegister)
ThreeByte(Multiply, ThreeRegister)
ThreeByte(Divide, ThreeRegister)
ThreeByte(Modulo, ThreeRegister)
ThreeByte(And, ThreeRegister)
ThreeByte(Or, ThreeRegister)
ThreeByte(GreaterThan, ThreeRegister)
ThreeByte(LessThan, ThreeRegister)
ThreeByte(Xor, ThreeRegister)
ThreeByte(ShiftRight, ThreeRegister)
ThreeByte(ShiftLeft, ThreeRegister)
ThreeByte(Equals, ThreeRegister)
ThreeByte(Pow, ThreeRegister)
ThreeByte(AddUnsigned, ThreeRegister)
ThreeByte(SubtractUnsigned, ThreeRegister)
ThreeByte(MultiplyUnsigned, ThreeRegister)
ThreeByte(DivideUnsigned, ThreeRegister)
ThreeByte(ModuloUnsigned, ThreeRegister)
ThreeByte(AndUnsigned, ThreeRegister)
ThreeByte(OrUnsigned, ThreeRegister)
ThreeByte(GreaterThanUnsigned, ThreeRegister)
ThreeByte(LessThanUnsigned, ThreeRegister)
ThreeByte(XorUnsigned, ThreeRegister)
ThreeByte(ShiftRightUnsigned, ThreeRegister)
ThreeByte(ShiftLeftUnsigned, ThreeRegister)
ThreeByte(EqualsUnsigned, ThreeRegister)
ThreeByte(PowUnsigned, ThreeRegister)
ThreeByte(FloatingPointAdd, ThreeRegister)
ThreeByte(FloatingPointSubtract, ThreeRegister)
ThreeByte(FloatingPointMultiply, ThreeRegister)
ThreeByte(FloatingPointDivide, ThreeRegister)
ThreeByte(FloatingPointGreaterThan, ThreeRegister)
ThreeByte(FloatingPointLessThan, ThreeRegister)
ThreeByte(FloatingPointEquals, ThreeRegister)
ThreeByte(FloatingPointPow, ThreeRegister)
ThreeByte(AndBoolean, ThreeRegister)
ThreeByte(OrBoolean, ThreeRegister)
ThreeByte(XorBoolean, ThreeRegister)
ThreeByte(EqualsBoolean, ThreeRegister)
// code 3: FourByte [ variant:3 | op: 5 | control: 24 ]
//          SignedImm16          [ variant:3 [3] | op: 5 | unused: 8 | imm16 ] 
//          FourRegister         [ variant:3 [3] | op: 5 | dest: 4 | src0: 4 | src1: 4 | src2: 4 | unused: 8 ] // compact version
//          FiveRegister         [ variant:3 [3] | op: 5 | dest: 4 | src0: 4 | src1: 4 | src2: 4 | src3: 4 | unused: 4 ]
//          OneRegisterWithImm16 [ variant:3 [3] | op: 5 | dest: 4 | unused: 4 | imm16 ]
FourByte(Jump, SignedImm16)
FourByte(CallSubroutine, SignedImm16)
FourByte(DecodeBits, FourRegister)
FourByte(EncodeBits, FiveRegister)
FourByte(ConditionalBranch, OneRegisterWithImm16)
FourByte(ConditionalCallSubroutine, OneRegisterWithImm16)
FourByte(LoadImmediate16, OneRegisterWithImm16)
// code 4: EightByte [ variant:3 | op:5 | control: 56 ]
//         OneRegisterWithImm48  [ variant: 3 [4] | op: 5 | dest: 4 | unused: 4 | imm48 ]
EightByte(LoadImmediate48, OneRegisterWithImm48)
// code 5: FiveByte [ variant:3 | op: 5 | control: 32 ]
//          Immediate24          [ variant:3 [3] | op: 5 | unused: 8 | imm24] 
//          TwoRegisterWithImm16 [ variant:3 [3] | op: 5 | dest:4 | src0:4 | unused: 8 | imm16 ]
FiveByte(JumpAbsolute, Immediate24)
FiveByte(AddImmediate, TwoRegisterWithImm16)
FiveByte(SubtractImmediate, TwoRegisterWithImm16)
FiveByte(MultiplyImmediate, TwoRegisterWithImm16)
FiveByte(DivideImmediate, TwoRegisterWithImm16)
FiveByte(ModuloImmediate, TwoRegisterWithImm16)
FiveByte(AndImmediate, TwoRegisterWithImm16)
FiveByte(OrImmediate, TwoRegisterWithImm16)
FiveByte(GreaterThanImmediate, TwoRegisterWithImm16)
FiveByte(LessThanImmediate, TwoRegisterWithImm16)
FiveByte(XorImmediate, TwoRegisterWithImm16)
FiveByte(ShiftRightImmediate, TwoRegisterWithImm16)
FiveByte(ShiftLeftImmediate, TwoRegisterWithImm16)
FiveByte(EqualsImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedAddImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedSubtractImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedMultiplyImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedDivideImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedModuloImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedAndImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedOrImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedGreaterThanImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedLessThanImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedXorImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedShiftRightImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedShiftLeftImmediate, TwoRegisterWithImm16)
FiveByte(UnsignedEqualsImmediate, TwoRegisterWithImm16)
// code 6: GrabBag [ variant:3 | op: 5 | ... ] 
//         TwoRegister          [ variant: 3 [6] | op: 5 | dest: 4 | src: 4 ]
//         OneRegisterWithImm64 [ variant: 3 [6] | op: 5 | dest: 4 | unused: 4 | imm64 ]
//         OneRegisterWithImm32 [ variant: 3 [6] | op: 5 | dest: 4 | unused: 4 | imm32 ]
GrabBag(PrintString, TwoRegister) // read two registers to get start and length in memory
GrabBag(Minus, TwoRegister) // minus unsigned makes no sense
GrabBag(MinusUnsigned, TwoRegister)
GrabBag(MinusFloatingPoint, TwoRegister)
GrabBag(Not, TwoRegister) // not is implicitly unsigned and works for boolean ops as well
GrabBag(NotBoolean, TwoRegister)
GrabBag(NotSigned, TwoRegister)
GrabBag(LoadImmediate64, OneRegisterWithImm64)
GrabBag(LoadImmediate32, OneRegisterWithImm32)
// code 7: Unused!

